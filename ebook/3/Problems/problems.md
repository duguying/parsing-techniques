# 问题

**问题3.1**：假设给定语法中的所有终结符是不同的。语法是否明确？

**问题3.2**：编写一个程序, 给定一个语法G和一个数字n, 计算G允许的不同的有n个叶子(终端)的解析树的数量。

**问题3.3**：Problem 3.3: If you are familiar with an existing parser (generator), identify its parser components, as described on page 69.

**问题3.4**：Problem 3.4: The maze preprocessing algorithm in Section 3.5.4 eliminates all rooms with three walls; rules with two or four walls are acceptable in a deterministic maze. What about rooms with zero or one wall? How do they affect the algorithm and the result? Is it possible/useful to eliminate them too?

**问题3.5**：Problem 3.5: Construct an example in which a deterministic bottom-up parser will have to perform k actions at position k, for a certain k.

**问题3.6**：Problem 3.6: Project: There are several possible paths through the maze in Figure 3.10(b), so a maze defines a set of paths. It is easy to see that these paths form a regular set. This equates a maze to a regular grammar. Develop this analogy, for example: 1. Derive the regular grammar from some description of the maze. 2. How does the subset algorithm (Section 5.3.1) transform the maze? 3. Is it possible to generate a set of mazes so that together they define a given CF set?

**问题3.7**：Problem 3.7: Project: Study the “translate and cross out matching parentheses” parsing method of Greibach [389].

**问题3.8**：Problem 3.8: Show that a version of Figure 3.14 in which the nodes marked 2 near the top are combined represents parse trees that are not supported by the input.

**问题3.9**：Problem 3.9: Implement the backtracking algorithm sketched in Section 3.7.3.

**问题3.10**：Problem 3.10: Assume arithmetic expressions are parsed with the highly ambiguous grammar with an appropriate definition of Number. Design a criterion that will help prune the resulting parse forest to obtain the parse tree that obeys the usual precedences for the operators. For example, 4+5×6+8 should come out as ((4+(5×6))+8). Take into account that the first four operators are left-associative, but the exponentiation operator ↑ is right-associative: 6/6/6 is ((6/6)/6) but 6 ↑ 6 ↑ 6 is (6 ↑ (6 ↑ 6)).

![图1](../../img/3.12_1.png)

**问题3.11**：Problem 3.11: Research project: Some parsing problems involve extremely large CF grammar, with millions of rules. Such a grammar is generated by program and results from incorporating finite context conditions into the grammar. It is usually very redundant, containing many very similar rules, and very ambiguous. Many general CF parsers are quadratic in the size of the grammar, which for ten million rules brings in a factor of 1014. Can parsing techniques be designed that work well on such grammars? (See also Problem 4.5.)

**问题3.12**：Problem 3.12: Extensible Project: 1. A string S is balanced for a token pair (t1, t2) if #t1 = #t2 for S and #t1 ≥ #t2 for all prefixes of S, where #t is the number of occurrences of t in S or a prefix of it. A token pair (t1, t2) is a parentheses pair for a grammar G if all strings in L(G) are balanced for (t1, t2). Design an algorithm to check if a token pair (t1, t2) is a parentheses pair for a given grammar G: a) under the simplifying but reasonable assumption that parentheses pairs occur together in the right hand side of a rule (for example, as in F--->(E)), and b) in the general case.

2. A token t1 in position i in a string matches a token t2 in a position j if the string segment i+1· · · j−1 between them is balanced for (t1, t2). A parentheses pair (t1, t2) is compatible with a parentheses pair (u1,u2) if every segment between a t1 and its matching t2 in every string in L(G) is balanced for (u1,u2). Show that if (t1, t2) is compatible with (u1,u2), (u1,u2) is compatible with (t1, t2).

3. Design an algorithm to find a largest set of compatible parentheses pairs for a given grammar.

4. Use the set of parentheses pairs to structure sentences in L(G) in linear time.

5. Derive information from G about the segments of strings in L(G) that are not structured in that process, for example regular expressions.

6. Devise further techniques to exploit the parentheses skeleton of CF languages.