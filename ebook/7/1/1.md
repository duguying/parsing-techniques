# 7.1 通过搜索解析
剩下的唯一问题是如何使自动机通过所有得可能性。该问题可容易的看成是搜索问题，它可以通过深度优先或广度优先搜索方法来解决。我们现在可以看到机器是如何使用这两种搜索方法的。由于结果在大小上是指数级别的，所以即使是最小的例子也会变得非常大，我们将在Figure 7.4中使用这种不切实际的语法。

![图 7.1_0](../../img/7.1_Fig.7.4.png)
<center>Figure 7.4 展示目的的简单语法</center>

![图 7.1_1](../../img/7.1_Fig.7.5.png)
<center>Figure 7.5 深度优先解析的步骤</center>

## 7.1.1 深度优先（回溯）解析
参考Figure 7.5，在图中，移动断点显示为⌈，而非移动断点显示为⌉。起初，断点位于整个输入的左侧（a），移动是唯一的选择；（b）和（c）同样如此。在（d）中，我们有另一个选择，移动或者使用规则3缩小；我们选择移动，但是要记得缩小的可能。规则编号显示为堆栈中符号的下标。（e）同理。在（f）中，我们移动失败，缩小失败（右侧不是aaaab，aab，ab或者b），并且没有存储的选择。所以我们开始通过反向移动来回溯（g）。这里我们发现了一个存储着的选择，“通过（规则）3缩小”，我们在（h）中应用，删除当前步骤中存储的选择的索引。现在我们可以再一次移动（i）。（到此，）不可能再移动了，但是可以通过（规则）1缩小获得了一次解析（j）。享受成功后，我们不缩小了（k）；注意（k）仅仅在已经用过的选择1（规则1）上不同于（i）。反向移动，反缩小再反向移动带我们到了（n），这里我们找到了一个存储的选择，“通过规则3缩小”。缩小后（o），我们可以再一次移动，两次（p，q）。“通过规则2缩小”产生第二次解析（r）。剩下的路是空洞的：反缩小，反移位，反移位，反缩小（v）和三个反移位使自动机暂停，输入重建（y）。

![图 7.1_2](../../img/7.1_Fig.7.6.png)
<center>Figure 7.6 广度优先解析的步骤</center>

## 7.1.2 广度优先解析
广度优先自底向上解析比深度优先更容易，但是以更大的内存需求为代价。由于输入符号将被逐个输入（每个导致一次移位，可能跟随一些缩小），我们对部分解析的表示将只包括堆栈，及其附加的部分解析树。我们永远不需要做反移动或者反缩小。根据Figure 7.6，我们以一个空栈（a1）开始我们的解决方案集。每个解析步骤由两个阶段组成，阶段一中，下一个输入的符号被附加到解决方案集中所有堆栈的右侧；第二阶段中，所有堆栈会被检查，如果允许一个或多个缩小，则可以制作一个或多个副本，缩小将应用到这些副本上。这种方法不会错过任何一个解决方案。第一个和第二个仅仅是追加（b1，c1），但第三个允许缩小（d2）。第四个产生一个或多个缩小（e2），第五个产生两个缩小，每个产生一个解析（f4和f5）.