# 2.3.2 2型语法

2型语法被称为上下文无关语法（CF语法），其和上下文相关语法之间的关系如它们的名字所示。上下文无关语法和上下文相关语法是相似的，只是左侧和右侧的文字必须是空缺的（空的）。因此语法可能只包含一个规则，在其左侧只有一个非终结符。语法示例：

![图1](../../img/2.3.2_1.png)

### 2.3.2.1 独立生成

由于左侧总是只有一个符号，生成图中的每个节点具有这样的属性，无论其生成什么都独立于其相邻节点的生成：非终结符的生成周期独立于其上下文。我们在图2.4，2.6，2.8中见到的星型结构不可能发生在上下文无关语法中，因此就会有一个纯粹的树形结构，其被称为*生成树*。示例如图2.9。

![图2 Fig 2.9](../../img/2.3.2_2-Fig.2.9.png)

由于左侧只有一个符号，对于一个给定非终结符的所有右侧，可以放在同一个语法规则的集合中（在上述语法中我们已经做了），然后每个语法规则就像一个左侧的定义：

- 一个**Sentence**是后面接着**and**接着**Name**的**Name**或是**List**.
- 一个**List**是**Name**后面接着一个a，或接着**List**或是**Name**.

这显示了上下文无关语法构建字符串是经过了两个过程的：拼接（“...接着...”）和选择("要么...要么....")。除了这些过程在这里是识别机制，其链接了在右侧使用的非终结符的名字和定义规则（“...是一个...”）。

在这章节的开头，我们确定了一门语言作为字符串的一个集合，起始符号的终结符的生成物的集合。独立生成物的属性让我们可以把这个定义扩展到这个语法的任何非终结符上：每一个非终结符都生成一个集合、一门语言，独立于其他非终结符生成的。如果我们将A生成的字符串集合写作*L(A)*，而且A有两种可选的生成规则，*A → α|β*，那么*L(A) = L(α) $$\cup$$ L(β)*，*$$\cup$$*代表集合的并集运算符。这对应于上一段说到的选择。如果α由*PqR*三个字符组成，我们就有*L(α) = L(P) $$\circ$$ L(q) $$\circ$$ L(R)*，*$$\circ$$*代表字符串的串联运算符（实际上上集合中的字符串）。这对应于上一段说到的拼接。而*L(a)*中的a是终结符，属于集合{a}。语言中包含ε的非终结符被称为*空*。也可以说“生成空”。

注意，我们不能定义图Fig 2.7中Q的语言*L(Q)*：Q本身不能生成任何有意义的东西。为非起始符号定义语言只能在2型语法或更低级的语法上可能实现，将非起始的非终结符廷议为空也是一样的。

有关独立生成属性就是递归的概念。非终结符A是递归的，如果句子形式中的这个A可以生成再次包含A的东西。图Fig 2.9中的生成物开始于句子形式的Sentence，其使用了规则1.2来生成List和Name。下一步很可能是用Name,List来替换List，使用规则2.1。我们看到List生成了再次包含List的东西：

**Sentence ---> List and Name ---> Name , List and Name**

即List是递归的，尤其是，它是直接递归。非终结符A在**A--->Bc, B--->dA**中是间接递归的，不过这之间的差异并没有太多意义。

比之更重要的是List是右递归的：一个非终结符A是右递归的，如果它可以在右侧生成包含A的东西，则List为：

**List ---> Name , List**

同理，一个非终结符A是左递归的，如果它可以在左侧生成包含A的东西：我们就可以定义

**List ---> List , Name**

一个非终结符A是自嵌入的，有这样一个定义：如果A能在生成一个，左侧是α右侧是β中间依旧是A的东西。自嵌入描述了嵌套：α是进入另一层嵌套时生成的；β是结束这一层嵌套时生成的。嵌套最著名的例子是在算术表达式中括号的使用：

![图3](../../img/2.3.2_3.png)

一个非终结符可以同时时左递归的和右递归的；它就是自嵌入的。**A--->Ab|cA|d**就是一个例子。

如果一个语法中没有非终结符时递归的，则每一个生成步骤使用一个非终结符，因为这个非终结符绝不会再次出现在这个**段**中。所以生成过程不可能无限持续，结果就产生了一个有限的语言。递归是语法生命周期所必须的。

### 2.3.2.2 一些例子

在现实世界中，很多事物是根据其他事物来定义的。上下文无关语法是一种非常简洁的方式来制定这种相互关系。一个最浅显的例子就是一本书的组成，如图Fig 2.10所示。

![图4 Fig 2.10](../../img/2.3.2_4-Fig.2.10.png)

当然这是关于一本书的上下文无关描述，所以人们也可以期待其生成很多冠冕堂皇的废话，就像

![图5](../../img/2.3.2_5.png)

不过至少可以保证结果能得到正确的结构。文档编制和文本标记系统，如SGML、HTML、XML使用这种方式来表达和控制文档的基本结构。

一个比较简短但相对重要的例子是，使所有电梯回到原始出发点的运动的语言（被限制在第五大道的Manhattan龟也会有一样的运动轨迹）

![图6](../../img/2.3.2_6.png)

（我们假设电梯井使无限长的；第五大道也一样）。

如果我们忽略足够多的细节，我们也能认识到自然语言的句子中底层的上下文无关结构，例如英语：

![图7](../../img/2.3.2_7.png)

英语中生成像这样的句子：

**the well-read cats criticize the wistful caterpillar**

然而，因为没有上下文被纳入，它也会生成不不正确的形式

**the cats admires the white well-read castle**

为了保持上下文我们需要使用短语结构语法（为了更简单的语言）：

![图8](../../img/2.3.2_8.png)

标记Singular和Plural控制实际英文单词的生成。仍然，这个语法允许猫吠叫...。一种更好的控制上下文的方式，详见15章的各小节，尤其是Van Wijngaarde语法（15.2节）以及属性和词缀语法（15.3节）。

大部分的CF语法的列子来源于编程语言。这些语言（也就是程序）中的句子都必须自动处理（也就是，通过编译器），而且很快（大约1958年）人们就承认如果语言有一个良好定义的正式语法将会变得更容易。现今使用的所有编程语言的句法都是通过正式语言定义的。

一些作者（例如Chomsky）和一些解析算法，要求CF语法是单调的。CF规则为非单调的唯一方式是右侧为空。这一规则被称为*ε法则*，而不包含这类法则的语法被称为免ε。

免ε并不是一种限制，而只是一种妨碍。几乎任何一种CF语法都可以变成免ε的，通过ε法则的系统性替换；唯一的例外是一个语法的开头符号已经生成了ε。转换过程在4.2.3.1节有详细介绍，不过这里同时也介绍了其他很多语法的转换，而且不幸的是通常会破坏语法的结构。这个问题将在2.5节进一步讨论。

### 2.3.2.3 Notation Styles

There are several different styles of notation for CF grammars for programming languages, each with endless variants; they are all functionally equivalent. We shall show two main styles here. The first is the Backus-Naur Form (BNF) whichwas first used to define ALGOL 60. Here is a sample:

![图9](../../img/2.3.2_9.png)

This form’s main properties are the use of angle brackets to enclose non-terminals and of ::= for “may produce”. In some variants, the rules are terminated by a semicolon.

The second style is that of the CF van Wijngaarden grammars. Again a sample:

![图10](../../img/2.3.2_10.png)

The names of terminal symbols end in ...symbol; their representations are hardware-dependent and are not defined in the grammar. Rules are properly terminated (with a period). Punctuation is used more or less in the traditional way; for example, the comma binds tighter than the semicolon. The punctuation can be read as follows:

![图11](../../img/2.3.2_11.png)

The second rule in the above grammar would then read as: “a sentence is defined as a name, or as a list followed by an and-symbol followed by a name, and as nothing else.” Although this notation achieves its full power only when applied in the twolevel Van Wijngaarden grammars, it also has its merits on its own: it is formal and still quite readable.

### 2.3.2.4 Extended CF Grammars

CF grammars are often made both more compact and more readable by introducing special short-hands for frequently used constructions. If we return to the Book grammar of Figure 2.10, we see that rules like:

**SomethingSequence ---> Something | Something SomethingSequence**

occur repeatedly. In an extended context-free grammar we can write Something+ meaning “one or more Somethings” and we do not need to give a rule for Something+; the rule

**Something+ ---> Something | Something Something+**

is implicit. Likewise we can use Something* for “zero or more Somethings” and Something? for “zero or one Something” (that is, “optionally a Something”). In these examples, the operators +, * and ? work on the preceding symbol. Their range can be extended by using parentheses: (Something ;)? means “optionally a Something-followed-by-a-;”. These facilities are very useful and allow the Book grammar to be written more efficiently (Figure 2.11). Some styles even allow constructions like Something+4, meaning “one or more Somethings with a maximum of 4”, or Something+, meaning “one or more Somethings separated by commas”; this seems to be a case of overdoing a good thing. This notation for grammars is called Extended BNF (EBNF).

![图12 Fig 2.11](../../img/2.3.2_12-Fig.2.11.png)

The extensions of an EBNF grammar do not increase its expressive powers: all implicit rules can be made explicit and then a normal CF grammar in BNF notation results. Their strength lies in their user-friendliness. The star in the notation X∗ with the meaning “a sequence of zero or more Xs” is called the Kleene star. If X is a set, X∗ should be read as “a sequence of zero or more elements of X”; it is the same star that we saw in Σ∗ in Section 2.1.3.3. Forms involving the repetition operators *, + or ? and possibly the separators ( and ) are called regular expressions. EBNFs, which have regular expressions for their right-hand sides, are for that reason sometimes called regular right part grammars RRP grammars which is more descriptive than “extended context free”, but which is perceived to be a tongue twister by some.

There are two different schools of thought about the structural meaning of a regular right-hand side. One school maintains that a rule like:

**Book ---> Preface Chapter+ Conclusion**

is an abbreviation of

**Book ---> Preface α Conclusion**
**α ---> Chapter | Chapter α**

as shown above. This is the “(right)recursive” interpretation. It has the advantages that it is easy to explain and that the transformation to “normal” CF is simple. Disadvantages are that the transformation entails anonymous rules (identified by α here) and that the lopsided production tree for, for example, a book of four chapters does not correspond to our idea of the structure of the book; see Figure 2.12.

![图13 Fig 2.12](../../img/2.3.2_13-Fig.2.12.png)

The second school claims that

**Book ---> Preface Chapter+ Conclusion**

is an abbreviation of

![图14](../../img/2.3.2_14.png)

This is the “iterative” interpretation. It has the advantage that it yields a beautiful production tree (Figure 2.13), but the disadvantages are that it involves an infinite number of production rules and that the nodes in the production tree have a varying fan-out.

Since the implementation of the iterative interpretation is far from trivial, most practical parser generators use the recursive interpretation in some form or another, whereas most research has been done on the iterative interpretation.

![图15 Fig 2.13](../../img/2.3.2_15-Fig.2.13.png)